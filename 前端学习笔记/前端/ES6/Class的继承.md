## Class的继承

​	Class可以通过extends关键字实现继承

​	**super关键字，作为方法**时表示父类的构造函数  只能在子类的构造方法中调用

​	子类自己的this对象，必须通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其加工，加上子类自己的属性和方法，**如果不调用super方法，子类就得不到this对象**

​	ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（**所以必须先调用`super`方法**），然后再用子类的构造函数修改`this`。

#### 	注意点

- 如果子类没有定义`constructor`方法，这个方法会被默认添加
- **在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。**这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。
- 静态方法一样会被子类继承



### Object.getPrototypeOf)() 可以用来从子类上获取父类

### super关键字

- super作为函数调用时，代表父类的构造函数，子类构造函数必须执行一次super函数，虽然代表父类A的构造函数，但是返回的时子类B的实例，即

  super内部的this指的是子类的实例

  super()在这里相当于A.prototype.constructor.call(this)

  new.target指向当前正在执行的函数

- super作为对象使用，在普通方法中<=>父类的原型对象(父类实例上的方法或属性，是无法通过super调用的)

  ​									在静态方法中<=>指向父类
  
  - super在使用时候，必须标明super的数据类型函数or对象，否则会报错



子类的\_proto_ 属性指向父类

子类的prototype属性的\_proto_ 指向父类的prototype属性

ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。