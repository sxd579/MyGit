## Vue面试题高频考点

1. new Vue()都做了什么

   总分总

   1. 先给结论

      - new Vue()是创建Vue实例，它内部执行了根实例的初始化过程

   2. 分析细节

      - 选项合并，合并用户选项和默认选项

      - $children,$refs,$slots,$createElement等实例属性和方法初始化

      - 自定义事件处理

      - 数据响应式处理

      - 生命周期钩子调用beforeCreated 

        可以访问一些生命周期和事件相关的，数据还未初始化，不可以做数据交互和响应处理

        和created

        数据已经初始化，可以做数据交互和响应处理

        

      - 可能的挂载

   3. 总结一波

      - new Vue()创建了根实例并准备好数据和方法，未来执行挂载时，此过程还会递归的应用于它的子组件上，最终形成一个有紧密关系的组件实例树

2. new Vue得到的实例和组件实例有什么区别？

   - Vue实例有el指定挂载元素

     组件实例没有，

     因为组件也是通过调用再渲染页面，直接通过组件名渲染

   - Vue实例中data属性:data:{

        "name":"aa",

     }

     组件中的data属性data(){

     return{

       "name":"aa",

     }

     }

   - Vue实例的html元素是直接渲染到页面中，而****组件的html元素是定义在template上，通过调用再渲染到页面

   - 组件的html元素是定义在template上，通过调用再渲染到页面

3. 说一说对Vue响应式理解

   - 啥是响应式

     - 数据响应式就是用户对数据层做的更改能够触发视图层做出更新响应的机制

   - 为什么需要响应式

     - mvvm框架中要解决的一个核心问题就是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要实现一套响应式机制，这样一旦数据发生变化就可以立即做出更新处理

   - 它能给我们带来什么好处

     - 以vue为例说明，通过数据响应式加上虚拟DOM和patch算法，可以是我们只需要操作数据，完全不用接触繁琐的dom操作，从而大大提升开发效率，降低开发难度

   - vue的响应式是怎么实现的，有哪些优缺点

     (props,methods，computed，watch，data都是响应式的	)

     - vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应即通知更新；如果是数组则通过覆盖该数组的原型的方法，扩展它的七个变更方法，使这些方法可以额外的做更新通知， 从而做出响应，这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失(比如数组很大的情况)；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map，Set这些数据结构不支持等问题

   - vue3中响应式的新变化

     - 为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的proxy机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，我们甚至不需要引入vue都可以体验

4. nextTick

   Vue.nextTick([callback,context]);

   - nextTick是啥？

     - 是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法

   - 为什么需要它，用异步更新队列实现原理解释

     - Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作时非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。

   - 我在什么地方用它

     - 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法

   - 如何使用nextTick

     