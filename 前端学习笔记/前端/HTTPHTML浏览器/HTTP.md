## HTTP

1. HTTP

   - 超文本传输协议
   - 互联网上应用最广泛的协议
   - 是客户端与服务端请求和应答的的标准(tcp)
   - 用于WWW服务器发送超文本到浏览器的传输协议
   - 使浏览器更高效，使网络传输更少

2. HTTPS

   - HTTP的安全版
   - 在传输层实现SSL加密
   - 建立安全的通信通道，确保数据传输的保密性和完整性，确保网站的真实身份

3. HTTP与HTTPS的区别

   - HTTP使明文传输，HTTPS对数据加密以后传输
   - HTTPS需要CA证书，加个更高
   - HTTP的端口是80 HTTPS的端口是443
   - HTTP连接简单是无状态的。HTTPS是通过HTTP+SSL进行数据加密和身份认证比HTTP更安全

4. HTTPS的优点

   - 对传输的数据进行加密和和身份认证确保了数据的完整性
   - 对于用户和服务器的身份进行认证，确保数据发送到正确的客户端和服务器
   - HTTPS是目前最安全的，虽然不是绝对安全，但是大大增加了中间攻击的成本
   - HTTPS在谷歌搜索上排名比HTTP的网站靠前

5. HTTPS的缺点

   - 响应速度更慢，且更加耗电
   - HTTPS缓存不如HTTP，需要增加数据开销
   - HTTPS需要CA证书，安全性越高的证书，价格越高
   - 证书需要绑定IP地址，一个IP地址不可以绑定多个域名，IPv4支持不了这种消耗

6. HTTPS的过程

   - 客户端往服务器的443端口发送连接请求

   - 服务器返回给客户端一个公钥证书

   - 客户端验证公钥证书，比如证书绑定的站点，证书的有效事件

   - 在证书验证完毕以后，客户端通过随机数生成器，产生对称密钥，用证书中的公钥对于对称密钥进行加密，发送给服务器

   - 服务器用自己的私钥进行，解密，获得对称密钥，至此，客户端和服务器协商好了对称密钥

   - 当服务器需要向客户端发送信息的时候，将明文用对称密钥加密，

     然后客户端用对称密钥解密获得明文，反之，客户端向服务器发送信息时亦然

7. TCP三次握手

   客户端和服务端都需要做到各自可收发，因此需要三次握手

   - 第一次握手，客户端向服务器发送一个请求连接的报文SYN

     客户端变成SYN-Sent状态

     服务端确认可以收到客户端发来的报文

   - 第二次握手，服务器向客户端发送一个确认连接的报文SYN，ACK=SYN+1

     服务器变成SYN-RCVD状态

     客户端确认服务端已经收到自己发送的报文，且自己可以收到服务端发来的报文

   - 第三次握手，客户端往服务器发送一个确认报文，ACK=SYN+1

     服务端确认客户端可以收到自己发送的报文

     客户端和服务器都变ESTABLISHGED状态，	之后可以开始传输数据

8. TCP四次挥手

   - 第一次挥手，客户端向服务器发起断开连接的报文，FIN=1，客户端的状态变成FIN-Wait-1

   - 第二次挥手，服务器收到了客户端发来的断开连接的报文，返回给客户端一个ACK=FIN+1的报文，表示自己已经收到，但可能还没有准备好，客户端的状态变成FIN-Wait-2

   - 第三次挥手，服务器发客户端发送确认释放的报文，FIN=1

      服务器的状态变成LAST_ACK

   - 第四次挥手，客户端收到服务器确认释放的报文后，给服务器发送一个确认报文ACK=FIN+1，客户端的状态就变成了TIME_Wait，如果服务器没有收到ACK则重传第三次挥手，如果收到了则直接关闭连接，超过一段时间以后如果客户端没有收到服务端重传的消息，则关闭连接。

9. TCP和UDP的区别

   - TCP是面向连接的，UDP是无连接的

   - TCP是可靠的，发送的数据，不丢失，不出错，不重复，按序到达，适合大数据量的交换。UDP是不可靠的，尽最大努力交付，而不保证交付，适合IP电话，视频会议等

   - TCP是面向字节流的，UDP是面向报文流的，UDP不会因为网络的阻塞而降低发送速度，所以会出现丢包的现象

   - TCP头20字节，UDP头8字节

   - TCP1对1，UDP1对1或1对多的

     （面向连接的，所以双方通信时，需要建立连接，使用连接，释放连接，只有当与上一方通信结束，释放连接之后，才能与其他方继续建立连接通信）

       （无连接的，每一个数据包上有目标的ip地址，可以同时给多方发送，所以是1对多的）

10. HTTP1.0/1.1/2.0

   - HTTP1.0最主要问题是连接无法复用，导致每次请求都要经历三次握手和慢启动，三次握手请求在高延迟的场景下影响明显，慢启动则对文件类大请求影响较大

   - HTTP1.1 克服HTTP1.0的缺陷，支持持久连接，在一个TCP连接上传送多个HTTP请求和响应，减少了建立和关闭连接的消耗的延迟。

     - 一个包含多个图像的网页文件的多个请求和应答可以在一个连接中传输。但是每个单独的网页文件仍然需要使用各自的连接。
     - HTTP1.1还允许了不需要等上一次请求request 收到响应response就可以开始下一次请求，不过服务器的返回的response响应结果是按照请求的顺序的，用以保证客户端可以区分是哪个请求的，这样也显著减少了整个下载过程所需要的时间
     - 在request和response头都出现了一个字段connection的头，此header的含义是client和server对于长连接，是如何处理的。默认都是开启长连接的，如果一方想支持长连接则需要在请求响应头明确说明connection的值为close。如果有这个值则和HTTP1.0一样，每个请求都必须创建新的tcp连接
     - HTTP1.1还增加了HOST字段来明确访问服务器上的哪个web站点，以及提供了身份认证，状态管理，Cache缓存机制相关的请求头和响应头，相比1.0还支持了断点续传。

   - HTTP2.0

     - 多路复用

       HTTP1.1通过建立多个TCP连接，来支持处理多并发请求，创建连接是有开销的

       HTTP2.0则使用多路复用技术，使同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级

     - 二进制分帧

       改进传输性能，实现低延迟和高吞吐量。

     - 首部压缩

       随着Web功能越来越复杂，每个页面的请求越来越多，导致消耗在头部的流量越来越多，尤其每次都需要传输UserAgent，Cookie这类不会频繁变动的内容，很浪费，2.0用HPACK算法对于头部进行压缩，这样子在网络上传输的更快

     - 服务端推送

       在客户端请求之前发送数据的机制，因为服务器必须等待浏览器的每一个请求，导致空闲的网络没有被充分利用，为了改善延迟，2.0引入了server push，在浏览器明确的请求之前，服务器推送资源给浏览器，免得客户端再创建连接去服务器请求在，这样子更加充分利用网络，客户端可以在本地加载这些资源，不需要通过网络

11. 强缓存的协商缓存

    第一次向服务器请求时候，返回的response中cache-control字段中包含max-age即文件的过期时间，以及etag，文件的hash值每个文件只有一个，以及last modified 上一次修改文件的时间

    当第二次以后打开浏览器，先查看缓存文件是否过期，如果没有过期，则是强缓存，强制使用缓存文件。如果已经过期了，则协商缓存，向服务器发起请求，在请求头设置if-none-matched:etag  if-modified-since:last-modified，服务器比对etag，和modefied字段，如果相同则返回304状态码，浏览器使用之前的缓存，如果不同，则返回200状态，像第一次请求一样。

12. 为什么要有etag

    因为一些文件的周期性修改，内容不改变，仅仅修改时间，不希望因此认为文件被修改，且last modified 只能精确到秒，秒以下的无法判断。

    且某些服务器不能精确的得到文件的最后缓存时间。

13. Cookie与localStorage与sessionStorage的区别

    cookie的数据始终在同源的HTTP请求中携带即使不需要

    cookie最大是4k，而webStorage最大是5M

    cookie有自己的路径，不同的浏览器储存路径不同，所以即使同源，不同浏览器也不能共享cookie

    不同浏览器不能共享sessionStorage和localStorage

    同一浏览器的所有同源窗口可以共享localStorage和cookie

    ​                    而sessionStorage在不同标签页不共享。

    sessionStorage在关闭浏览器前有效

    localStroage永久有效

    cookie在过期前有效，没有设定过期时间是关闭

14. cookie 和 session的区别

    - cookie是储存在客户的浏览器上， session是存在的服务器上的
    - cookie储存在本地，可以被分析并且进行Cookie欺骗，考虑到安全应该使用session
    - session会在一定时间保存在服务器上，如果访问多的话，产生大量session会影响服务器的性能，考虑到性能应该使用cookie
    - 单个cookie不能超过4k，很多浏览器限制一个站点的cookie不超过20个

15. GET和POST的区别

    - GET请求的参数通过URL传递，POST请求通过request body传递
    - GET请求的参数只接受ASIIC类型，POST请求可以接受多种类型
    - GET请求的参数有长度限制，POST请求没有
    - GET请求只能通过url编码，POST可以有多种编码方式
    - GET请求可以被BookMark，POST不可以
    - GET请求浏览器会主动Cache,POST需要手动设置
    - GET请求的参数会被保存在浏览器历史记录中,POST不会
    - GET请求回退是无害的，POST请求回退会再次发起请求
    - GET请求参数直接暴露在URL中，相比不安全，不适合传递敏感信息
    - GET请求会产生一个TCP数据包，POST会产生两个(FF中只长生一个)
    - 
    - GET参数通过URL传递，POST通过request body传递
    - GET请求回退是无害的，POST会再次发起请求
    - GET产生的URL地址可以被BOOKMark，POST不可以
    - GET传送的参数长度有限制，POST传送的参数长度没有限制
    - GET的参数只接受ASIIC类型，POST则没有限制
    - GET请求只能进行url编码，POST可以多种编码
    - GET请求会被浏览器主动cache，POST需要手动设置
    - GET请求的参数会保存在浏览器历史记录中，POST不会
    - GET参数直接暴露在URL上比POST不安全，不能用来传递敏感信息
    - GET只产生一个TCP数据包，POST产生两个TCP数据包(FireFox只产生一个)

16. 在地址栏输入一个URL到这个页面呈现出来，中间发生了什么

    - 浏览器的地址输入URL回车
    - 寻找URL域名的ip，为了寻找这个ip，浏览器首先寻找缓存，查看缓存中是否有记录，缓存的查找记录为 浏览器缓存->系统缓存->路由器缓存，缓存中没有则查找系统中的hosts文件是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址
    - 先三次握手，然后构造HTTP请求，将其封装在一个tcp包中，发送给对方服务器，服务器解析这个请求来做出响应，返回响应的html给浏览器
    - 浏览器根据html来构建DOM树，在DOM树构建过程中如果遇到JS脚本和外部JS连接，则停止构建DOM树，来执行和下载相应的代码，这会造成阻塞，所以推荐JS代码应该放在html代码的后面。根据内部样式，外部样式，内联样式形成CSSOM树，构建完毕以后和DOM树合成为渲染树，这是主要是为了排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确认各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解释DOM的过程中遇到就进行并行下载，并行下载数量有限制一般是4-6个。所有请求需要需要检查缓存，就是强制缓存和协商缓存，强制缓存就直接使用缓存内容，协商缓存。渲染
    - 关闭TCP连接四次挥手

17. URL 统一资源定位符   URI统一资源标识符

18. HTTP状态码

    - 100 Continute继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认(第二次发送真正的请求信息)

    - 101 协议升级 webSocket  http2

    - 200 OK 正常返回信息

    - 201 Created 请求成功并且服务器创建了新的资源

    - 202 Accepted 服务器已接受了请求，但尚未处理

    - 301 请求网页已经永久移动到了新位置，返回此响应自动将请求者转向新位置

    - 302  服务器现在正从不同位置的网页响应请求，但是请求者应该继续使用原有位置请求。

    - 303  对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI

    - 307 对于POST请求，它表示请求未被处理，客户端应该向Location里的URI重新发起POST请求。

    - 304 用于HTTP的协商缓存，对服务器请求文件是否修改，如果未修改则返回304状态码，表示使用本地缓存

    - 400  语法错误，服务器无法理解语义，即实体的类型和名字不一致，

      或者没有转换成JSON字符串，解决方法，通过比对属性名和类型，以及将obj通过JSON.stringfy序列化

    - 401 请求未经授权

    - 403 服务器理解语义，但是拒绝了用户的请求

    - 404 没有找到请求的网页

    - 500 服务器端的错误

    - 503 服务器暂时无法处理请求，可能是维护或者过载

19. WebSocket

    是HTML5的协议，三次握手阶段采取了HTTP的方式，添加了两个字段

    一个是upgrade:websocket  一个是connection:upgrade

    使用HTTP获取数据，采取的是轮询的方式，这样子对服务器的性能影响大。WebSocket是长连接建立一次连接，那么这个连接就不会断，服务端如果有数据的话，就自动返回给客户端。且HTTP各个请求间是无联系的，所以要加入cookie，而WebSocket是一次长连接，就不需要一次次加入cookie了。

